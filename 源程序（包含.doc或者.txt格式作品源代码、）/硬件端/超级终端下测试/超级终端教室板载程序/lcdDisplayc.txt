//  包含必要的头文件
#include "lcdDisplay.h"

char Picture[1024] = {     
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xFC,0x00,0x00,0x07,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x03,0xF0,0x00,0x00,0x13,0xA0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x00,0x00,0x24,0x50,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x00,0x24,0x50,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0F,0xC0,0x00,0x00,0x27,0x90,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x25,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x00,0x00,0x24,0x90,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x14,0x60,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xFC,0x03,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xFF,0xFF,0xFF,0xF9,0xFC,0x7F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0xFF,0xFF,0xF9,0xF9,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0xFF,0xFF,0xF3,0xF9,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x03,0xFF,0xFF,0xFF,0xE7,0xF3,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xFF,0xFF,0xFF,0xE7,0xE7,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x1F,0xCF,0xE7,0xFF,0x03,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x1F,0x9F,0xCF,0xF0,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x3F,0x9F,0x9F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x3F,0x3F,0x9F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x7E,0x7F,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xFE,0x7E,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xFC,0xFE,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xF9,0xFC,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0xF9,0xF9,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0xF3,0xF9,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x07,0xE7,0xF3,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0F,0xE7,0xE3,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0F,0xCF,0xE7,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1F,0x9F,0xCF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3F,0x9F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7E,0x7F,0xFF,0xFF,0xFE,0x3F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xFE,0x7F,0xFF,0xFF,0xFC,0x3F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0xFC,0xFF,0xFF,0xFF,0xFC,0x7F,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0xF9,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x03,0xF9,0xFF,0xFF,0xFF,0xF1,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x07,0xF2,0x00,0x00,0x00,0x00,0x00,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0F,0xFC,0x00,0x0F,0xF0,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1F,0xF8,0x00,0x0F,0xF8,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1F,0xF0,0x00,0x07,0xFC,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x3F,0xF0,0x00,0x07,0xFC,0x00,0x01,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0xE0,0x00,0x03,0xFE,0x00,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0xC0,0x00,0x03,0xFF,0x00,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xFF,0xC0,0x00,0x01,0xFF,0xC0,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0x80,0x00,0x00,0xFF,0xF0,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0x00,0x00,0x00,0x7F,0xFE,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x03,0xFF,0xFF,0xFF,0xFE,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xFF,0xFF,0xFF,0xFF,0x1F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xFF,0xFF,0xFF,0xFF,0x8F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0F,0xFF,0xFF,0xFF,0xFF,0xE3,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xF0,0x7F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void LCD_Init(void)
{
    SysCtlPeriEnable(LCD_KEY_PERIPH);                       //   使能GPIO B口LCD控制接口
    GPIOPinTypeOut(LCD_KEY_PORT , LCD_KEY_CS);              //   设置CS,CLK,DIO为输出
    GPIOPinTypeOut(LCD_KEY_PORT , LCD_KEY_DIO);
    GPIOPinTypeOut(LCD_KEY_PORT , LCD_KEY_CLK);
    GPIOPinTypeOut(LCD_KEY_PORT , LCD_KEY_PSB);
    GPIOPinTypeOut(LCD_KEY_PORT , LCD_KEY_RST);
    
    GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_PSB, 0x00);          //设置为串口
    GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_RST, 0xFF);          //取消复位
	
    LCD_ComdWrite(0x30); //   功能设定,基本指令?为什么设置成8位模式???是不是因为每一个都是8位的数？？
                         //字节内容：高四位001 DL（1：8位MPU接口，且必须为1；0：4位MPU接口）
                        //字节内容：低四位0 RE(0:基本指令；1：扩充指令) 00
    LCD_ComdWrite(0x30);                           
    LCD_ComdWrite(0x0c);//字节内容：0000 0D（整体显示开关）C（游标开关）B（游标位置反白）
                      // 整体显示开,游标关,反白关
    LCD_ComdWrite(0x01); //   清除显示
    LCD_ComdWrite(0x06); //   进入设定点,游标右移,画面不移动
                         //字节内容：0000 01 I/D(游标移动方向：1右移DDRAM地址计数器（AC）加1，
	                 //0左移)  S（显示画面整体位移？？？？）
}
//延时iTime个微妙
void __delayNuS (unsigned long iTime)
{
    iTime = SysCtlClockGet() * iTime / 2000000;             //  根据系统时钟速率确定延时
    while (--iTime != 0);
}

//  清屏
void clear_All(void)
{
    LCD_ComdWrite(0x01);   //直接调用写命令函数
    __delayNuS(50);
}

////////////////////////////////////////////////////////////////////////////////////////
////                                                                             ///////
////                               简单的字符显示                                                                         ///////
////                                                                             ///////    
///////////////////////////////////////////////////////////////////////////////////////
//下面连续的三个函数是最基本的函数，实现MPU向LCD写数据和指令，第一个函数为第二、三个函数服务
//？？？但有一问题：没有检测  忙信号？？？
//  向LCM写入一个字节，这个函数中可以得到时钟信号，先低后高，周期为10us
void LCD_ByteWrite(char Bytename)
{
    char i, dat;

    for( i=0; i<8; i++ )                                    // 循环写一个字节的数据
    {
        GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_CLK, 0x00);      //时钟信号写低电平
        __delayNuS(5);                                      //  延时5us
        dat = Bytename & 0x80;           //得到最高位的值

        if( dat )    //最高位是1，就写数据为1
            {
                GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_DIO, 0xff);  //写数据为1
            }
        else        //最高位是0，就写数据是0
            {
                GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_DIO, 0x00);
            }

        Bytename  <<=  1;    //写字节的下一位
        GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_CLK, 0xff);      //时钟信号写高电平
//        __delayNuS(50);                                     //应该延时5us
        __delayNuS(5);                                      //  延时5us
    }
}

//  向LCM写命令
void LCD_ComdWrite(char comd)
{
    GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_CS, 0xff);    //片选信号置成高电平，使能模块
    LCD_ByteWrite(0xf8);    //同步字节，1111 1 RW（0写） RS（0指令） 0
                                 //作用是MPU写指令到IR（指令寄存器）
                                 //通俗表达：请注意我要开始发命令了（就是在同步）
    //下面写的这两个字节才是真正的命令
    LCD_ByteWrite(comd & 0xf0);//第一个字节的内容为：D7 D6 D5 D4 0 0 0 0   
    comd  <<=  4;   //左移四位把comd的低四位提到高四位
    LCD_ByteWrite(comd & 0xf0);//第二个字节的内容为：D4 D3 D2 D1 0 0 0 0
}

//  向LCM写数据
void LCD_DataWrite(char data)
{
    GPIOPinWrite(LCD_KEY_PORT, LCD_KEY_CS, 0xff); //同样先使能
    LCD_ByteWrite(0xfa);  //同样是同步字节，1111 1 RW（0写） RS（1数据） 0
                               //作用是MPU写数据到DR（数据寄存器）
                               //通俗表达：请注意我要开始发数据了（同样是在同步）
    //这三行与上面类似，只不过是在写数据罢了
    LCD_ByteWrite(data & 0xf0);
    data <<= 4;
    LCD_ByteWrite(data & 0xf0);
}
//上述的三个最基本函数完毕


//////////////////////////////////////////////////////////////////////////////////////
////                                                                             /////
////                   图形显示                                                 //////
////                                                                             /////
//////////////////////////////////////////////////////////////////////////////////////

//  开启图片显示功能
void LCD_PictureOn(void)
{
    LCD_ComdWrite(0x34);     //使能扩充指令               //  Expand instruction
    //字节内容是：001 DL（1:8位MPU接口） 0 RE(1:扩充指令) 00
    LCD_ComdWrite(0x36);//这条就是扩充指令
    //字节内容是：001 DL（1:8位MPU接口） 0 RE（1:扩充指令） G（1:绘图显示开） 0
    LCD_ComdWrite(0x30);    //再变成基本指令             //  Base instruction
}

//  关闭图片显示功能
void LCD_PictureOff(void)
{
	LCD_ComdWrite(0x34); //使能扩充指令                        //  Expand instruction
	LCD_ComdWrite(0x30); //这是扩充指令，绘图显示关  
	LCD_ComdWrite(0x30); //再变成基本指令                     //  Base instruction

}

void LCD_GdramAddress(char VerticalAddr,char HorizontalAddr)    //竖直行，水平列
{
    VerticalAddr &= 0x1F;     //竖直与
    HorizontalAddr &= 0x0F;   //水平与
    LCD_ComdWrite(0x34);                             //  Expand instruction G=Off
    LCD_ComdWrite(VerticalAddr|0x80);   
    LCD_ComdWrite(HorizontalAddr|0x80);
    LCD_ComdWrite(0x30);                            //  Base instruction
}

//这个函数不大懂
//  上电初始化图形显示缓冲区数据， 显示LOGO图形128*64点阵  
void LCD_PowerOnPictureInit_disp(void)
{
    unsigned char i,j;
    char *p;

    p = Picture;     //PowerOnPicture就是本文件刚开始的数组名，p是指针

    for(i=0;i<32;i++)          // 这只是上半屏
   {
     LCD_GdramAddress(i,0);  //i表示行，现在是第0列
     for(j=0;j<16;j++)     //写入的每一个数据都是8位的（恰好一个字节），
                                //这样正好是16个字节,恰好是一行128点阵（12864点阵）
     {                   //一个汉字占两个字节，一行共可写8个汉字。  
       LCD_DataWrite(*p);
       p++;
      }
    }
        //上下屏问题
    for(i=0;i<32;i++)
    {
      LCD_GdramAddress(i,8);   //行地址怎么又成8了？？
      for(j=0;j<16;j++)
      {    
        LCD_DataWrite(*p);
        p++;
       }
     }
}

//##################################################################################
//##                在任意位置显示字符串                                     #######             
//##################################################################################

unsigned char LCD_SetPos(int X,int Y)   //X表示行号
{
  unsigned char SendChar;
  switch (X)
  {
    case 1:
      SendChar =0x80+Y - 1;
      break;
    case 2:	
      SendChar =0x90+Y - 1;
      break;
    case 3:
      SendChar =0x88+Y - 1;
      break;
    case 4:
      SendChar =0x98+Y - 1;
      break;
    default: 
      SendChar =0x80+Y - 1;
      break;
  }
  return SendChar;
}

void LCD_WriteStr(int X,int Y,char * String)
{
  unsigned char temp;
  unsigned char CharCodeH;
  unsigned char CharCodeL;
  temp = LCD_SetPos(X,Y);
  LCD_ComdWrite(temp);
         
  while(1)
  {
    CharCodeH = *String++;  //把汉字的高8位给CharCodeH
                       //如果是汉字中的标点符号的话只占一个字节，
                        //虽然低8位是空格但是不会执行判断语句
    CharCodeL = *String++;  //把汉字的低8位给CharCodeL
    if(CharCodeH == '\0') break;   //只判断汉字的高8位
    LCD_DataWrite(CharCodeH);  //连续写两个字节
    LCD_DataWrite(CharCodeL);  //对于中文一次写一个汉字，对于英文一次写两个字母且不会出现“空格”现象
    //if(CharCodeH == '\0') break; //在这里会先显示最后的“\0”,并会乱码
    switch (temp)
    {
      case 0x87:
  	X = X + 1;
        temp = LCD_SetPos(X,1);
        LCD_ComdWrite(temp);
  	break;
      case 0x97:	
  	X = X + 1;
        temp = LCD_SetPos(X,1);
        LCD_ComdWrite(temp);
  	break;
      case 0x8f:
  	X = X + 1;
        temp = LCD_SetPos(X,1);
        LCD_ComdWrite(temp);
        break;
      case 0x9f:
  	X = 1;
        temp =LCD_SetPos(X,1);
        LCD_ComdWrite(temp);
  	break;
      default: 
  	temp=temp+1;
        break;
    }
  }
}

